[→ Open in Slid](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3)


---





**깃허브 전체 과정**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/acf1941a-f414-4527-aef6-32a49faa71a4.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=49.445314)





**git이란?**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/d4f5ee89-4f1d-4531-93a3-7d9468b547a7.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=82.493133)





**커밋 (commit)**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/4a72f738-1a75-453f-800f-e633a2799e54.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=114.43159084931946)


게임의 세이브포인트와 같은 개념 => 커밋한 시점으로 돌아갈 수 있도록. 저장을 원하는 파일을 묶어서 커밋 명령 수행





**스테이지에 올린다. (add)**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/b74d93d0-e263-4cfc-8f49-1e3290214fac.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=193.48622716021728)


저장을 원하는 파일을 묶어서 커밋을 수행하기 위해, 스테이지에 파일을 올려야함.


컴퓨터에 보이지 않는 장소에 스테이지가 생긴다.





**github에 업로드 (push)**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/772e23cc-37e3-4eaa-a695-044b86e8c28a.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=257.5769168588562)


커밋을 하면 이제 현제 작업 내용이 컴퓨터에 저장됨.


이것을 원격 저장소에 저장함으로써, 안전하게 보관할 수 있음


이 과정을 통해서 다른 사람과 공유할 수 있음





**Source Tree**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/07bba7a7-a648-4ff4-9685-2e56dbe59e1c.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=704.495314)


Bitbucket Server은 설치형으로 개별 서버를 설치한 경우 거기에 로그인을 할때 선택합니다.


\=> 2024년에 지원 종료될 예정임


Bitbucket은 Atlassian의 Bitbucket에 회원가입된 사용자가 로그인 할때 선택합니다.





1\. Bitbucket 으로 시작하기


2\. clone 클릭


3\. 원격 주소 복사 붙여넣기 생성








**Source Tree add**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/4084f30d-b4ae-4953-9ddf-d0bf2a608592.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=886.056856)





**Source Tree commit**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/3b527957-9bd7-45c2-a57f-562f3ef86275.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=940.7124819809266)


**커밋 규칙**


1\. 논리적인 작업만 커밋


2\. 메세지를 잘 적어야 함





**커밋 작성법**


1\. 첫 줄에 간단하지만 명확하게 내용을 씁니다.


2\. 한 줄 비우고


3\. 자세한 내용을 적습니다.





**예제**

```
hello.html 파일 생성
깃과 깃허브 공부용 hello.html 작성
생애 첫 깃 커밋

```





**Source Tree Push**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/c2c83f29-ac58-4527-b9cf-dc30c50abcb7.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=dbc3e0c6016f468194c7ba453d978018&start=1044.411681)





커밋할 때 로그인을 해야하는데,


아래 명령어로 전역 사용자를 설정할 수 있음

```
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```


그리고


**저장소 - 저장소 설정** 에서 고급설정에 들어가면 전역 사용자 사용하기를 쓸 수 있음





다만!


위 과정과 관계없이 logon fail이 계속 뜨는 경우가 있음


이 때는 원인이 여러가지 있을 수 있겠지만,


**소스트리와 깃허브가 연동이 되어 있지 않은 경우**


에러가 날 수 있다.


소스트리를 통해서 깃허브에 커밋하는 것은,


로컬의 컴퓨터에서 원격지로 소스를 날리는 것과 같다.


깃허브 입장에서, 소스를 푸쉬하려는 컴퓨터가 인증된 사용자인지 확인이 필요한데,


푸쉬할 때 마다, 깃허브 로그인을 하는 것이 아닌


사용자에게 토큰을 발급함으로써, 이 컴퓨터는 증명된 컴퓨터임을 증명할 수 있는 것이다.


푸쉬할 때 마다, 로그인하거나, 세션을 통해서 관리하는 것은 한 컴퓨터에서 지속적으로 작업하게 되는 **개발**특성상 어려운 것 같고, 대신 OAuth 토큰을 발급해서 사용하고 있는 것 같다.\\


**1\. 계정 추가하기**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/image_upload/89e5cd7e2f594a1ca416fb8f5f2147a3/dd571714-5a7a-41f1-ad64-ea66d7d024ca.png)](undefined)





2\. github 인증 토큰 발급받기

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/image_upload/89e5cd7e2f594a1ca416fb8f5f2147a3/ce52d9ef-6d32-4321-8237-35a09d397169.png)](undefined)








**마지막 커밋으로 돌아가기**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/image_upload/89e5cd7e2f594a1ca416fb8f5f2147a3/fe1e81eb-5136-4424-a125-483c4b0a57ee.png)](undefined)


Source Tree의 **코드뭉치되돌리기** 기능이다.





**브랜치**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/93707f82-7621-498b-a088-f2ab6edacc5f.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=db91a76b7077411a9703be81dc27b8d3&start=169.366556)


새로운 기능을 개발할 때, 기존 기능은 유지하고 새로운 개발을 하고자 할 때, 브랜치를 변경하도록 한다.








**브랜치 변경 (****checkout****)**


더블 클릭으로 브랜치를 변경한다.





**HEAD 브랜치**


현재 작업중인 브랜치


브랜치가 변경 되었을 경우 해당 브랜치를 HEAD 브랜치라고 함


브랜치를 변경하면 해당 브랜치에 반영된 커밋만 있음








**master 브랜치**


기본 브랜치임


최종 작업 본만 master에 들어있어야 함











**병합 (merge)**


https://learngitbranching.js.org/?locale=ko


위 사이트에서 병합에 대해서 배워볼 수 있음

```
- clone: 원격 저장소 복사
- add: 스테이지 영역에 작업 파일 추가
- commit: 세이브, 스테이지 영역의 파일들을 가지고 커밋(=세이브)를 만들 수 있다.
- push: 원격 저장소에 커밋을 업로드한다.
- checkout: HEAD 브랜치를 변경한다.
```


위 명령어를 이용해서





**병합하기**


 1. 병합할 대상에 checkout
 2. merge 하기


작업 중인 내용을 커밋하지 않고 브랜치를 변경하는 경우


작업 내용을 가지고 이동할 수 있지만, 작업내용을 가지고 이동하면 문제가 될 수 있으므로 커밋을 하고 checkout을 해야한다





상황 1.


\- Fast forward merge : 가장 쉬운 merge 상황. 하나의 브랜치에서 기능이 개발되고, merge 되는 경우.


head 브랜치에 변경 사항은 없고 병합 대상 브랜치가 헤드로 부터 시작된 경우 아주쉽게 병합가능


혼자 작업할 때 가장 많이 발생하는 상황. 별도로 커밋을 하나 생성하지 않고, branch의 마지막 커밋이 master 의 커밋이 된다.

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/26e50e83-77db-492f-9741-2d612ecfa060.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=e69e1d8e95ab44979d70b2b7b72703b3&start=207.38563897520447)





상황 2.


브랜치를 여러개로 나누어서, 하나의 브랜치가 먼저 개발이 되고, 나머지 브랜치가 개발이 되는 경우. 브랜치간의 충돌이 발생할 수 있음. 합치려는 모든 브랜치의 커밋에 하나의 커밋이 더 생김

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_markup_images/89e5cd7e2f594a1ca416fb8f5f2147a3/76191ba9-8660-4eb7-9cd8-c20435d2b88a.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=e69e1d8e95ab44979d70b2b7b72703b3&start=370.9021938874664)




[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/cdf946c1-c3af-4639-9ece-d2f47bfbc821.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=e69e1d8e95ab44979d70b2b7b72703b3&start=525.9926201125336)


1\. 위에서 선택할 소스를 고르고


2\. 스테이지에 소스 올림


3\. 커밋





위상황에서 충돌이 나지 않는 경우는


먼저 fast forwarding이 먼저 일어난 후


merge가 일어난다.





**브랜치 삭제**


브랜치들은 merge가 된 경우 안전하게 삭제가 가능하다.





**pull**


원격 저장소의 내용을 모두 내려받는 것


깃허브의 master가 내 로컬의 master 보다 더 앞선 경우 pull 할 내용이 생긴다.


pull이란 fetch + merge 인데


fetch 는 원격 저장소로부터 필요한 파일을 다운로드만 하는 것이고 병합은 따로 해야함


하나하나 변경 사항들을 확인해가며 병합할 수 있다는 장점은 있음








**pull의 충돌**


브랜치간의 충돌상황과 동일하다고 볼 수 있음


pull이나 merge를 실패한 경우 되돌리기를 고려할 수도 있음


에디터에서 제공하는 기능을 사용해서 저장소것과 로컬것 중 어떤 것을 사용할 것인지 선택할 수 있도록 해줌























**이전 커밋으로 되돌리기**


 1. reset
 2. 새로운 브랜치 만들기
 3. revert





**reset**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/48996b5c-1d44-478f-bfae-50c2eec77ed1.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=9a6bcc1ab7ed47aba45870b0788f4439&start=38.2774858626709)


쉽고 간편하게 내용을 지울 수 있으나,


원격에 없는 내용을 reset해서 커밋 기록 자체를 지우면 원격 저장소에 내용이 없는 한 되돌릴 수 없음


그리고 이전 원격 저장소와 커밋 기록이 달라지는 것이기 이후 커밋을 하려면 강제 푸쉬가 필요합니다.

```
$ git push --force
```





강제 푸쉬를 하지 않고 해결하려고 하면,


 1. 로컬의 내용과 원격의 내용을 merge 후 발생하는 충돌을 해결한다.
 2. 커밋 후 푸쉬한다.


이 경우, rebase를 사용하면 조금 더 부드럽게 해결이 가능하다.








**새로운 브랜치 만들기**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/4acfec96-6814-48e4-888b-9fba6344f4f8.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=9a6bcc1ab7ed47aba45870b0788f4439&start=203.52048203242492)


쉽게 해결이 가능하나, 트리가 지저분해짐


되돌리고 싶은 시점에 새로운 branch를 만들어서, 수정을 하고


수정한 브랜치와 원격저장소의 내용을 병합.(원격 내용에 수정한 것을 병합)


이때 사용은 수정한 버전 것을 사용한 뒤(충돌해결) 푸쉬하면 됨








주의할 점!

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/952a743c-ccb2-4360-9726-19cfb021aa3c.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=9a6bcc1ab7ed47aba45870b0788f4439&start=459.9200290038147)


master 브랜치가 원격이므로, 원격 브랜치에서 수정한 브랜치를 병합했다면!


"내것"을 사용해서 합치면 안되고


"저장소"것을 사용해서 합쳐야 한다.


여기서 저장소가 로컬인것 같다.








**revert**


커밋이 없어지지 않고 정석적으로 커밋을 되돌리는 방법이다.


이 후 푸쉬하면 된다.


source tree의 커밋 되돌리기 기능이다.


단점은 충돌 나기가 쉽다는 점이다.

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/018beda6-9ebb-4a83-a6d9-9cf733862a29.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=c8c15c0016a543028bc8f644901508d2&start=114.79417695040894)


여러가지의 커밋을 되돌리려면, revert를 반복 적용하면 됩니다.




[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/e0d82706-3cbf-429e-96f4-44906312fbd7.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=c8c15c0016a543028bc8f644901508d2&start=410.75242589891053)


한번에 이전 시점으로 커밋 되돌리기를 하면 상당히 많은 충돌이 남.


따라서, 커밋 되돌리기를 할 때는 커밋 하나씩 되돌리기를 하는 것이 정답이다.

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/image_upload/89e5cd7e2f594a1ca416fb8f5f2147a3/120c18f5-7e62-4c3c-a237-d3eadb226340.png)](undefined)

```
$ git revert HEAD HEAD~1
$ :wq
$ :wq
```


위 명령어로 되돌리는 것이 편함


HEAD는 가장 최근 커밋을 의미하고


HEAD~1 은 HEAD의 부모 커밋을 의미한다.











**브랜치 체크아웃시 주의사항**


브랜치를 체크아웃 할 때는 현재 작업중인 내용이 없어야 한다.





긴급하게 체크아웃이 필요한 경우


 1. 브랜치 1에서 일단 임시 커밋을 한다.
 2. 브랜치 2로 체크아웃하고 작업한다.
 3. 다시 1 브랜치 1로 되돌아 온다.
 4. 1의 작업을 마무리한다.
 5. 커밋 덮어쓰기 (commit --amend)를 한다.
 6. 필요하다면 (push --force)를 한다.





커밋 덮어쓰기 기능은 source tree의 커밋 옵션(커밋 정정)으로 선택할 수 있다.

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/d03c9c6e-353f-4c69-ae9a-99d8f440772a.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=66123d9459ae4ab9940a705f458e1e10&start=334.51586483215334)








다만, 이미 push한 커밋에 덮어쓰기 하는 경우


새로운 브랜치가 생겨버린다.


이때 저장본으로 강제 push가 필요하다.


임시 커밋은 서버로 보내지 않는 것이 베스트이다.











**Stash 를 이용하기**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/537a0068-e3c1-4f67-bd4f-ef37a3940de6.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=66123d9459ae4ab9940a705f458e1e10&start=585.5441669809265)


스태시를 이용하면

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/3466e265-6559-42a0-806b-e2336e1d5c8b.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=66123d9459ae4ab9940a705f458e1e10&start=697.9978031811982)


위와 같이 스태시라고 하는 임시 저장 공간에 저장이 되는데,


이를 우클릭해서 스태시 적용을 누르면 된다


다만, 신규파일을 생성하는 경우는 스태시가 적용되지 않음


따라서, 스테이지에 올린 후, 스태시로 만들면 됨





**rebase**

[![github 사용법 image](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/89e5cd7e2f594a1ca416fb8f5f2147a3/2cff7511-cf09-4302-8fac-6d59ea438922.png)](https://slid.cc/vdocs/89e5cd7e2f594a1ca416fb8f5f2147a3?v=df3509bff30e46e5aaea98165a360e99&start=65.43122017738342)


source tree의 재배치 라는 명령어이다.


커밋 히스토리가 깔끔하게 정리된다는 장점은 있으나, 이미 원격 저장소에 올라가고 협업하고 있는 경우 사용이 매우 위험하다.


원격에 이미 몰라간 경우는 절대 rebase 하지 말라
